/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 * File: EOM.c
 *
 * MATLAB Coder version            : 5.1
 * C/C++ source code generated on  : 06-Apr-2021 13:11:18
 */

/* Include Files */
#include "EOM.h"
#include "EOM_types.h"
#include "dyn_mid_step.h"
#include "loadsTt1.h"
#include "massT1.h"
#include "pinv.h"
#include "sprdmpKx18.h"
#include "sprdmpTt18.h"
#include "sprdmpVd18.h"
#include <math.h>
#include <string.h>

/* Function Definitions */
/*
 * Arguments    : double t
 *                const double z[34]
 *                const struct0_T *par_mex
 *                double dz[34]
 *                double *flag
 * Return Type  : void
 */
void EOM(double t, const double z[34], const struct0_T *par_mex, double dz[34],
         double *flag)
{
  static struct0_T b_par_mex;
  double TMT[289];
  double b_TMT_tmp[289];
  double T[102];
  double TMT_tmp[102];
  double b_w_vd_j_tmp[102];
  double c_TMT_tmp[102];
  double w_vd_j_tmp[102];
  double M_tmp[36];
  double TMfd[17];
  double b_TMfd[17];
  double w_sd[17];
  double w_vd_j[17];
  double b_tmp[6];
  double c_par_mex[6];
  double dv[6];
  double t12;
  double t2;
  double t23;
  double t25;
  double t27;
  double t2_tmp;
  double t3;
  double t53;
  double t60;
  double t82;
  double t83;
  double t9;
  int i;
  int i1;
  int i2;
  int sn;
  b_par_mex = *par_mex;
  dyn_mid_step(t, &b_par_mex);

  /* ROMF */
  /*     [OUT1,OUT2] = ROMF(IN1,IN2,S,DS,T_SYM) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.6. */
  /*     06-Apr-2021 12:55:52 */
  t2_tmp = b_par_mex.var[17] + b_par_mex.var[15];

  /* MASSM1 */
  /*     OUT1 = MASSM1(IN1,IN2,S,DS,T_SYM) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.6. */
  /*     06-Apr-2021 12:56:06 */
  t2 = b_par_mex.var[8] * b_par_mex.var[8];
  t3 = b_par_mex.var[9] * b_par_mex.var[9];
  t25 = -(b_par_mex.var[1] * (t2 + -t3) * 3.1415926535897931);
  t12 = t25 * (t2 / 4.0 + t3 / 4.0);
  M_tmp[0] = t25;
  M_tmp[1] = 0.0;
  M_tmp[2] = 0.0;
  M_tmp[3] = 0.0;
  M_tmp[4] = 0.0;
  M_tmp[5] = 0.0;
  M_tmp[6] = 0.0;
  M_tmp[7] = t25;
  M_tmp[8] = 0.0;
  M_tmp[9] = 0.0;
  M_tmp[10] = 0.0;
  M_tmp[11] = 0.0;
  M_tmp[12] = 0.0;
  M_tmp[13] = 0.0;
  M_tmp[14] = t25;
  M_tmp[15] = 0.0;
  M_tmp[16] = 0.0;
  M_tmp[17] = 0.0;
  M_tmp[18] = 0.0;
  M_tmp[19] = 0.0;
  M_tmp[20] = 0.0;
  M_tmp[21] = t12;
  M_tmp[22] = 0.0;
  M_tmp[23] = 0.0;
  M_tmp[24] = 0.0;
  M_tmp[25] = 0.0;
  M_tmp[26] = 0.0;
  M_tmp[27] = 0.0;
  M_tmp[28] = t12;
  M_tmp[29] = 0.0;
  M_tmp[30] = 0.0;
  M_tmp[31] = 0.0;
  M_tmp[32] = 0.0;
  M_tmp[33] = 0.0;
  M_tmp[34] = 0.0;
  M_tmp[35] = t25 * (t2 / 2.0 + t3 / 2.0);
  massT1(b_par_mex.var, z, 1.0E-6 * t2_tmp, T);

  /* MASSFG1 */
  /*     OUT1 = MASSFG1(IN1,IN2,S,DS,T_SYM) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.6. */
  /*     06-Apr-2021 12:56:41 */
  for (i = 0; i < 17; i++) {
    for (i1 = 0; i1 < 6; i1++) {
      t12 = 0.0;
      for (i2 = 0; i2 < 6; i2++) {
        t12 += T[i2 + 6 * i] * M_tmp[i2 + 6 * i1];
      }

      TMT_tmp[i + 17 * i1] = t12;
    }

    for (i1 = 0; i1 < 17; i1++) {
      t12 = 0.0;
      for (i2 = 0; i2 < 6; i2++) {
        t12 += TMT_tmp[i + 17 * i2] * T[i2 + 6 * i1];
      }

      TMT[i + 17 * i1] = t12;
    }
  }

  c_par_mex[0] = b_par_mex.var[12];
  c_par_mex[1] = b_par_mex.var[13];
  c_par_mex[2] = b_par_mex.var[14];
  c_par_mex[3] = 0.0;
  c_par_mex[4] = 0.0;
  c_par_mex[5] = 0.0;
  for (i = 0; i < 6; i++) {
    b_tmp[i] = c_par_mex[i];
  }

  sprdmpTt18(b_par_mex.var, z, 1.0E-6 * t2_tmp, w_vd_j_tmp);
  massT1(b_par_mex.var, z, 0.999999 * t2_tmp, T);
  sprdmpTt18(b_par_mex.var, z, 0.999999 * t2_tmp, b_w_vd_j_tmp);
  for (i = 0; i < 17; i++) {
    for (i1 = 0; i1 < 6; i1++) {
      t12 = 0.0;
      for (i2 = 0; i2 < 6; i2++) {
        t12 += T[i2 + 6 * i] * M_tmp[i2 + 6 * i1];
      }

      c_TMT_tmp[i + 17 * i1] = t12;
    }

    for (i1 = 0; i1 < 17; i1++) {
      t12 = 0.0;
      for (i2 = 0; i2 < 6; i2++) {
        t12 += c_TMT_tmp[i + 17 * i2] * T[i2 + 6 * i1];
      }

      b_TMT_tmp[i + 17 * i1] = t12;
    }
  }

  for (i = 0; i < 289; i++) {
    TMT[i] = (TMT[i] * t2_tmp + b_TMT_tmp[i] * t2_tmp) / 2.0;
  }

  sprdmpVd18(b_par_mex.var, z, 1.0E-6 * t2_tmp, c_par_mex);
  sprdmpVd18(b_par_mex.var, z, 0.999999 * t2_tmp, dv);
  for (i = 0; i < 17; i++) {
    t12 = 0.0;
    t23 = 0.0;
    t2 = 0.0;
    t3 = 0.0;
    for (i1 = 0; i1 < 6; i1++) {
      i2 = i + 17 * i1;
      t25 = b_tmp[i1];
      t12 += TMT_tmp[i2] * t25;
      t23 += c_TMT_tmp[i2] * t25;
      t2 += w_vd_j_tmp[i2] * c_par_mex[i1];
      t3 += b_w_vd_j_tmp[i2] * dv[i1];
    }

    TMfd[i] = (t12 * t2_tmp + t23 * t2_tmp) / 2.0;
    w_vd_j[i] = (t2 * t2_tmp + t3 * t2_tmp) / 2.0;
  }

  sprdmpKx18(b_par_mex.var, z, 1.0E-6 * t2_tmp, c_par_mex);
  sprdmpKx18(b_par_mex.var, z, 0.999999 * t2_tmp, dv);
  for (i = 0; i < 17; i++) {
    t12 = 0.0;
    t23 = 0.0;
    for (i1 = 0; i1 < 6; i1++) {
      i2 = i + 17 * i1;
      t12 += w_vd_j_tmp[i2] * c_par_mex[i1];
      t23 += b_w_vd_j_tmp[i2] * dv[i1];
    }

    w_sd[i] = (t12 * t2_tmp + t23 * t2_tmp) / 2.0;
  }

  for (sn = 0; sn < 9; sn++) {
    t2 = ((double)sn * 0.1 + 0.100001) * t2_tmp;
    massT1(b_par_mex.var, z, t2, T);
    for (i = 0; i < 17; i++) {
      for (i1 = 0; i1 < 6; i1++) {
        t12 = 0.0;
        for (i2 = 0; i2 < 6; i2++) {
          t12 += T[i2 + 6 * i] * M_tmp[i2 + 6 * i1];
        }

        TMT_tmp[i + 17 * i1] = t12;
      }

      for (i1 = 0; i1 < 17; i1++) {
        t12 = 0.0;
        for (i2 = 0; i2 < 6; i2++) {
          t12 += TMT_tmp[i + 17 * i2] * T[i2 + 6 * i1];
        }

        b_TMT_tmp[i + 17 * i1] = t12;
      }
    }

    for (i = 0; i < 289; i++) {
      TMT[i] += b_TMT_tmp[i] * t2_tmp;
    }

    sprdmpTt18(b_par_mex.var, z, t2, w_vd_j_tmp);
    sprdmpVd18(b_par_mex.var, z, t2, c_par_mex);
    for (i = 0; i < 17; i++) {
      t12 = 0.0;
      t23 = 0.0;
      for (i1 = 0; i1 < 6; i1++) {
        i2 = i + 17 * i1;
        t12 += TMT_tmp[i2] * b_tmp[i1];
        t23 += w_vd_j_tmp[i2] * c_par_mex[i1];
      }

      TMfd[i] += t12 * t2_tmp;
      w_vd_j[i] += t23 * t2_tmp;
    }

    sprdmpKx18(b_par_mex.var, z, t2, c_par_mex);
    for (i = 0; i < 17; i++) {
      t12 = 0.0;
      for (i1 = 0; i1 < 6; i1++) {
        t12 += w_vd_j_tmp[i + 17 * i1] * c_par_mex[i1];
      }

      w_sd[i] += t12 * t2_tmp;
    }
  }

  for (i = 0; i < 17; i++) {
    TMfd[i] /= 10.0;
    w_vd_j[i] /= 10.0;
    w_sd[i] /= 10.0;
  }

  /*  EOM */
  for (i = 0; i < 289; i++) {
    b_TMT_tmp[i] = TMT[i] / 10.0;
  }

  pinv(b_TMT_tmp, TMT);

  /* LOADSFTAU1 */
  /*     OUT1 = LOADSFTAU1(IN1,IN2,S,DS,T_SYM) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.6. */
  /*     06-Apr-2021 13:09:45 */
  t9 = b_par_mex.var[16] * 2.0;
  t23 = z[1] * t2_tmp;
  t25 = z[5] * t2_tmp;
  t27 = z[9] * t2_tmp;
  t3 = z[14] * t2_tmp;
  t12 = t2_tmp * t2_tmp;
  t2 = b_par_mex.var[16] - t2_tmp;
  t53 = t2 * t2;
  t60 = 1.0 / (exp(t2_tmp * -200.0 + b_par_mex.var[16] * 200.0) + 1.0);
  t3 = ((z[12] * t2_tmp / 2.0 + z[13] * t12 / 2.0) + t3 * t12 / 2.0) + -(t53 *
    t60 * (((((z[13] + b_par_mex.var[16] * z[16]) + z[14] * t9) + -z[15]) + t3)
           + -(z[16] * t2_tmp)) / 2.0);
  t2 = (t2_tmp * 2.0 + -t9) * t60;
  t82 = ((z[0] * t2_tmp * 2.0 + t2_tmp * t23 * 3.0) + -((z[1] + -z[3]) * t53 *
          t60)) + -(t2 * (((((z[0] + b_par_mex.var[16] * z[3]) + z[1] * t9) +
    -z[2]) + t23) + t2_tmp * -z[3]));
  t83 = ((z[4] * t2_tmp * 2.0 + t2_tmp * t25 * 3.0) + -((z[5] + -z[7]) * t53 *
          t60)) + -(t2 * (((((z[4] + b_par_mex.var[16] * z[7]) + z[5] * t9) +
    -z[6]) + t25) + t2_tmp * -z[7]));
  t2 = (((z[8] * t2_tmp * 2.0 + t2_tmp * t27 * 3.0) + -((z[9] + -z[11]) * t53 *
          t60)) + -(t2 * (((((z[8] + b_par_mex.var[16] * z[11]) + z[9] * t9) +
            -z[10]) + t27) + t2_tmp * -z[11]))) + 1.0;
  t23 = cos(t3);
  t12 = sin(t3);
  t25 = 1.0 / sqrt((t82 * t82 + t83 * t83) + t2 * t2);
  t2 = sqrt(t2 * t25 / 2.0 + 0.5);
  t3 = 1.0 / t2;
  t9 = t23 * t2;
  t53 = t12 * t2;
  t60 = t12 * t83 * t25 * t3 / 2.0 + t23 * t82 * t25 * t3 / 2.0;
  t2 = t12 * t82 * t25 * t3 / 2.0 + -(t23 * t83 * t25 * t3 / 2.0);
  t3 = (t9 * b_par_mex.var[23] + t53 * b_par_mex.var[24]) + -(t60 *
    b_par_mex.var[25]);
  t25 = (t53 * b_par_mex.var[25] + t60 * b_par_mex.var[24]) + t2 *
    b_par_mex.var[23];
  t12 = (t9 * b_par_mex.var[25] + t60 * b_par_mex.var[23]) + -(t2 *
    b_par_mex.var[24]);
  loadsTt1(b_par_mex.var, z, TMT_tmp);
  memcpy(&T[0], &TMT_tmp[0], 102U * sizeof(double));
  c_par_mex[0] = b_par_mex.var[20];
  c_par_mex[1] = b_par_mex.var[21];
  c_par_mex[2] = b_par_mex.var[22];
  t23 = (t9 * b_par_mex.var[24] - t53 * b_par_mex.var[23]) + t2 * b_par_mex.var
    [25];
  c_par_mex[3] = ((-t60 * t12 + t2 * t25) + t53 * t23) + t9 * t3;
  c_par_mex[4] = ((t60 * t25 + t2 * t12) + t9 * t23) - t53 * t3;
  c_par_mex[5] = ((t60 * t3 - t2 * t23) + t9 * t12) + t53 * t25;
  for (i = 0; i < 17; i++) {
    t12 = 0.0;
    for (i1 = 0; i1 < 6; i1++) {
      t12 += T[i + 17 * i1] * c_par_mex[i1];
    }

    t23 = 0.0;
    for (i1 = 0; i1 < 17; i1++) {
      t23 += 0E7 * b_TMT_tmp[i + 17 * i1] * z[i1 + 17];
    }

    b_TMfd[i] = (((TMfd[i] + w_sd[i]) + w_vd_j[i]) + t12) - t23;
  }

  for (i = 0; i < 17; i++) {
    t12 = 0.0;
    for (i1 = 0; i1 < 17; i1++) {
      t12 += TMT[i + 17 * i1] * b_TMfd[i1];
    }

    dz[i] = z[i + 17];
    dz[i + 17] = t12;
  }

  *flag = 0.0;
}

/*
 * File trailer for EOM.c
 *
 * [EOF]
 */
