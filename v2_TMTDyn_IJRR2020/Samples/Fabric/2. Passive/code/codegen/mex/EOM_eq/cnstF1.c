/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * cnstF1.c
 *
 * Code generation for function 'cnstF1'
 *
 */

/* Include files */
#include <string.h>
#include "mwmathutil.h"
#include "rt_nonfinite.h"
#include "EOM_eq.h"
#include "cnstF1.h"
#include "error.h"
#include "EOM_eq_data.h"

/* Variable Definitions */
static emlrtRSInfo mab_emlrtRSI = { 15,/* lineNo */
  "cnstF1",                            /* fcnName */
  "/home/hadi/MEGAsync/Hadi/AutoTMTDyn/Code/AutoTMTDyn/Beta/v1.0/Fabric/code/cnstF1.m"/* pathName */
};

static emlrtRSInfo nab_emlrtRSI = { 16,/* lineNo */
  "cnstF1",                            /* fcnName */
  "/home/hadi/MEGAsync/Hadi/AutoTMTDyn/Code/AutoTMTDyn/Beta/v1.0/Fabric/code/cnstF1.m"/* pathName */
};

static emlrtRSInfo oab_emlrtRSI = { 17,/* lineNo */
  "cnstF1",                            /* fcnName */
  "/home/hadi/MEGAsync/Hadi/AutoTMTDyn/Code/AutoTMTDyn/Beta/v1.0/Fabric/code/cnstF1.m"/* pathName */
};

static emlrtRSInfo pab_emlrtRSI = { 19,/* lineNo */
  "cnstF1",                            /* fcnName */
  "/home/hadi/MEGAsync/Hadi/AutoTMTDyn/Code/AutoTMTDyn/Beta/v1.0/Fabric/code/cnstF1.m"/* pathName */
};

static emlrtRSInfo qab_emlrtRSI = { 20,/* lineNo */
  "cnstF1",                            /* fcnName */
  "/home/hadi/MEGAsync/Hadi/AutoTMTDyn/Code/AutoTMTDyn/Beta/v1.0/Fabric/code/cnstF1.m"/* pathName */
};

static emlrtRSInfo rab_emlrtRSI = { 22,/* lineNo */
  "cnstF1",                            /* fcnName */
  "/home/hadi/MEGAsync/Hadi/AutoTMTDyn/Code/AutoTMTDyn/Beta/v1.0/Fabric/code/cnstF1.m"/* pathName */
};

/* Function Definitions */
void cnstF1(const emlrtStack *sp, const real_T in1[6], const real_T in2[198],
            real_T out1[91], real_T out2[91], real_T *out3)
{
  real_T t2;
  real_T t3;
  real_T t4;
  real_T t5;
  real_T t16;
  real_T t6;
  real_T t11;
  real_T t7;
  real_T t10;
  real_T t15;
  emlrtStack st;
  emlrtStack b_st;
  st.prev = sp;
  st.tls = sp->tls;
  b_st.prev = &st;
  b_st.tls = st.tls;

  /* CNSTF1 */
  /*     [OUT1,OUT2,OUT3] = CNSTF1(IN1,IN2,S) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.2. */
  /*     08-Jan-2019 02:46:01 */
  *out3 = in1[4];
  st.site = &mab_emlrtRSI;
  t2 = in2[3] * in2[3];
  st.site = &nab_emlrtRSI;
  t3 = in2[4] * in2[4];
  st.site = &oab_emlrtRSI;
  t4 = in2[5] * in2[5];
  t5 = ((-t2 - t3) - t4) + 1.0;
  st.site = &pab_emlrtRSI;
  if (t5 < 0.0) {
    b_st.site = &vg_emlrtRSI;
    b_error(&b_st);
  }

  t16 = muDoubleScalarSqrt(t5);
  t6 = 1.0 / t16;
  st.site = &qab_emlrtRSI;
  out1[0] = 1.0;
  out1[1] = 0.0;
  out1[2] = 0.0;
  t11 = in2[3] * in2[4];
  out1[3] = in2[5] * -0.27 + t11 * t6 * 0.27;
  out1[4] = t3 * t6 * 0.27 - t16 * 0.27;
  out1[5] = in2[3] * -0.27 + in2[4] * in2[5] * t6 * 0.27;
  memset(&out1[6], 0, 85U * sizeof(real_T));
  st.site = &rab_emlrtRSI;
  t7 = 1.0 / muDoubleScalarPower(t5, 1.5);
  t10 = in2[3] * t6 * 0.27 + in2[3] * t3 * t7 * 0.27;
  t11 = t11 * in2[5] * t7 * 0.27;
  t15 = in2[5] * t6 * 0.27 + in2[5] * t3 * t7 * 0.27;
  t5 = in2[4] * t6;
  t16 = t5 * 0.27;
  out2[0] = 0.0;
  out2[1] = 0.0;
  out2[2] = 0.0;
  out2[3] = (t10 * in2[103] + (t11 - 0.27) * in2[104]) + in2[102] * (t16 + in2[4]
    * t2 * t7 * 0.27);
  out2[4] = (in2[103] * (t5 * 0.81 + in2[4] * t3 * t7 * 0.27) + t10 * in2[102])
    + t15 * in2[104];
  out2[5] = ((t11 - 0.27) * in2[102] + t15 * in2[103]) + in2[104] * (t16 + in2[4]
    * t4 * t7 * 0.27);
  memset(&out2[6], 0, 85U * sizeof(real_T));
}

/* End of code generation (cnstF1.c) */
