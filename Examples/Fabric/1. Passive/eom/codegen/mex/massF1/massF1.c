/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * massF1.c
 *
 * Code generation for function 'massF1'
 *
 */

/* Include files */
#include <string.h>
#include "mwmathutil.h"
#include "rt_nonfinite.h"
#include "massF1.h"

/* Function Definitions */
void massF1(const emlrtStack *sp, const real_T in1[6], const real_T in2[224],
            real_T s, real_T out1[36], real_T out2[636], real_T out3[636],
            real_T out4[6])
{
  static const real_T dv0[36] = { 0.0024, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0024,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0024, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0E-9,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0E-9, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0E-9 };

  int32_T i;
  static const real_T dv1[6] = { 0.0, 0.0, -9.81, 0.0, 0.0, 0.0 };

  real_T t3;
  real_T t2;
  real_T t5;
  real_T t6;
  (void)sp;
  (void)in1;
  (void)s;
  memcpy(&out1[0], &dv0[0], 36U * sizeof(real_T));
  for (i = 0; i < 6; i++) {
    out4[i] = dv1[i];
  }

  /* MASSF1 */
  /*     [OUT1,OUT2,OUT3,OUT4] = MASSF1(IN1,IN2,S) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.2. */
  /*     06-Jul-2019 05:27:38 */
  t3 = in2[105] / 2.0;
  t2 = muDoubleScalarCos(t3);
  t3 = muDoubleScalarSin(t3);
  t5 = t2 * t2;
  t6 = t3 * t3;
  memset(&out2[0], 0, 630U * sizeof(real_T));
  out2[630] = t5 * -0.135 + t6 * 0.135;
  out2[631] = 0.0;
  t3 *= t2;
  out2[632] = t3 * 0.27;
  out2[633] = 0.0;
  out2[634] = t5 + t6;
  out2[635] = 0.0;
  memset(&out3[0], 0, 630U * sizeof(real_T));
  out3[630] = t3 * in2[217] * 0.27;
  out3[631] = 0.0;
  out3[632] = t5 * in2[217] * 0.135 - t6 * in2[217] * 0.135;
  out3[633] = 0.0;
  out3[634] = 0.0;
  out3[635] = 0.0;
}

/* End of code generation (massF1.c) */
